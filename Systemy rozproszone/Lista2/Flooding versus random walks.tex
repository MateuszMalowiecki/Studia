\documentclass[10pt, a4paper]{article}

\usepackage[english]{babel}
\usepackage{polski}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{200B}{{\hskip 0pt}}
\DeclareUnicodeCharacter{2212}{-} 
\usepackage{graphicx}
\begin{document}
\begin{titlepage}
\begin{center}
\large
\textbf{Mateusz Małowiecki}

\vspace{0.4cm}
\Large
\textbf{Opracowanie noty 2.6 (\textit{Flooding versus random walks}) z rozdziału 2 (\textit{Architectures}) książki \textit{Distributed Systems}\footnote{Van Steen M., Tanenbaum A.S.: \textit{ Distributed Systems 3rd edition.}}}

\vspace{0.4cm}
\large
\textbf{19 marca 2021}
\end{center}
\end{titlepage}
\section*{Wstęp}
Na pierwszy rzut oka, może się wydawać, że algorytm \textit{flooding} jest dużo lepszy niż algorytm \textit{random walks}, gdyż przeszukuje na raz więcej węzłów i jest w stanie szybciej znaleźć rozwiązanie. Jednak w praktyce często mamy do czynienia ze zwielokrotnionymi danymi i badania pokazały, że nawet w przypadku, gdy współczynnik zwielokrotnienia jest niewielki, algorytm \textit{random walks} jest nie tylko efektywny, ale też bardziej wydajny od algorytmu \textit{flooding}.
\section*{Obliczenia (algorytm \textit{random walks})}
Załóżmy, że mamy \textit{N} węzłów, każdy element danych znajduje się na \textit{r} losowo wybranych maszynach. Poszukiwania polegają na losowym wybieraniu kolejnych węzłów, póki poszukiwany element nie zostanie znaleziony. Jeśli $P[k]$ jest prawdopodobieństwem znalezienia elementu po \textit{k} próbach, to:​
\begin{equation}
P[k] = \frac{r}{N}*(1-\frac{r}{N})^{k-1}
\end{equation}
Niech $S$ będzie oczekiwaną liczbą węzłów, które musimy odwiedzić przed znalezieniem żądanej pozycji danych. Wtedy:
\begin{equation}
S = \sum_{k=1}^{n} k * P[k] = \sum_{k=1}^{n} k *\frac{r}{N}*(1-\frac{r}{N})^{k-1}
\end{equation}
Stosując proste przekształcenia, można oszacować, że $S \approx N/r $. Możemy zatem zauważyć, że jeśli $r = N$, to $S=1$, więc algorytm \textit{random walks} jest wtedy lepszy od algorytmu \textit{flooding}. Aczkolwiek gdy $r$ jest dużo mniejsze niż $N$ (przykładowo $r/N = 0.1\% $), to oczekiwana liczba węzłów wyniesie około 1000.
\section*{Obliczenia (algorytm \textit{flooding})}
W celu dokonania porównania między algorytmem \textit{random walks} a algorytmem \textit{flooding} załóżmy, że w algorytmie \textit{flooding} pierwszy wierzchołek wysyła komunikat do $d$ wybranych sąsiadów, a każdy następny wierzchołek przesyła go dalej do $d-1$ wybranych sąsiadów. Wówczas po $k$ krokach osiągniemy co najwyżej
\begin{equation}
R(k) = d*(d − 1)^{k − 1}
\end{equation}
węzłów. Zatem jeżeli wykonamy $k$ kroków (dla takiego $k$, że $\frac{r}{N}*R(k) \geq 1 $) to z dużym prawdopodobieństwem znajdziemy węzeł, który zawiera poszukiwany element danych.
\section*{Porównanie}
Rozważmy jeszcze raz przypadek, kiedy  $r/N = 0.1\%$ (czyli $S \approx 1000$). Jeśli w algorytmie \textit{flooding} przyjmiemy $d=10$ to po czterech krokach  osiągniemy 7290 węzłów, czyli zdecydowanie więcej niż 1000. Jednak dla $d=33$, po zaledwie 2 krokach osiągniemy ok. 1000 węzłów i jednocześnie spełnimy warunek $\frac{r}{N}*R(k) \geq 1$. Oczywistą wadą algorytmu \textit{random walks} jest też to, że wdrażanie tego algorytmu może potrwać znacznie dłużej, zanim odpowiedź zostanie zwrócona.
\end{document}