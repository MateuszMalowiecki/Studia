1. W tym zadaniu należy porównać czytanie pliku za pomocą jednowątkowego serwera
plików i serwera wielowątkowego. Otrzymanie zamówienia na pracę, skierowanie go do
wykonania i uporanie się z resztą niezbędnego przetwarzania zajmuje 15 ms, pod warunkiem
że potrzebne dane są w pamięci podręcznej utrzymywanej w pamięci operacyjnej. Jeżeli
powstaje konieczność wykonania operacji dyskowej, co stanowi jedną trzecią ogółu zamówień,
trzeba dodatkowych 75 ms, podczas których wątek jest uśpiony. Ile zamówień na sekundę
może obsłużyć serwer jednowątkowy? A serwer wielowątkowy? (Zanim podasz odpowiedź
liczbową przedstaw rozwiązanie).

Odpowiedź:
W przypadku serwera jednowątkowego czas przetwarzania pojedynczego zamówienia zajmuje 
15 sek. (jeżeli wszystkie potrzebne dane są w Cache'u), lub 90 sek. (w przeciwnym przypadku).
Średnia ważona wynosi więc 2/3 * 15 + 1/3 * 90 = 10 + 30 = 40 ms. Więc taki serwer jest w stanie
obsłużyć 25 zamówień na sekundę.
W przypadku serwera wielowątkowego oczekiwania wątków nakładają się na siebie, więc każde zamówienie trwa 15 ms,
a więc serwer jest w stanie obsłużyć 66 2/3 zamówienia na sekundę.

2. Czy dałoby się uzasadnić ograniczenie liczby wątków w procesie serwera?

Odpowiedź:
Tak z dwóch powodów:
a) Wątki potrzebują pamięci do zainicjowania własnego stosu.
b) Niezależne wątki działają w sposób chaotyczny w systemie operacyjnym.

3. W treści rozdziału zawarto opis wielowątkowego serwera plików, podkreślając jego zalety 
w porównaniu z serwerem jednowątkowym i serwerem działającym niczym maszyna
o skończonej liczbie stanów. Czy istnieją okoliczności, w których serwer jednowątkowy może
okazać się lepszy? Jeśli tak, to podaj przykład. Jeżeli nie, to uzasadnij, dlaczego.

Odpowiedź:
Tak. Na przykład jeśli serwer jest całkowicie związany z procesorem.

4.Statyczne przypisanie tylko jednego wątku do procesu lekkiego nie jest zbyt dobrym pomysłem. Dlaczego? (Co to jest proces lekki? Wskazówka: poczytaj o systemie Solaris).

Odpowiedź:
Proces lekki(ang. light-weight process - LWP) - proces działający w przestrzeni jądra, w kontekście pojedynczego (ciężkiego) procesu.
Na dany proces ciężki może się składać kilka LWP.
Statyczne przypisanie jednego wątku do procesu lekkiego nie jest zbyt dobrym pomysłem, 
ponieważ w ten sposób ograniczamy się do posiadania wątków tylko na poziomie jądra.
5. Posiadanie tylko jednego procesu lekkiego w procesie również nie jest zbyt dobrym pomysłem. Dlaczego?

Odpowiedź:
W tym przypadku z kolei mamy wątki tylko na poziomie użytkownika, więc każde blokujące wywołanie sytemowe spowoduje blokadę całego procesu.

6. Opisz prosty schemat, w którym istnieje tyle procesów lekkich co wątków wykonywalnych.

Odpowiedź:
Zaczynamy z pojedynczym LWP i szukamy działającego wątku do wykonania. 
Jeśli znajdziemy taki wątek, to tworzymy nowe LWP i szukamy następnego wątku do wykonania.
Jeśli nie znajdziemy takiego wątku to LWP niszczy siebie.

7. W systemie X określa się terminal użytkownika jako serwer goszczący, natomiast o aplikacji
mówi się, że jest klientem. Czy to ma sens?

Odpowiedź:
Tak, to ma sens. Główna idea jest taka, że serwer kontroluje sprzęt,
a aplikacja może manipulować tym sprzętem, poprzez wysyłanie żądań manipulacji.

8. Protokołowi X dolegają problemy skalowalności. Jak można by sobie z nimi poradzić?

Odpowiedź:
Zasadniczo mamy dwa rodzaje problemów ze skalowalnością:

a) Skalowalność numeryczna (zbyt duża przepustowość jest wymagana):
W tym przypadku najlepiej zastosować techniki kompresji przepustowości.

b) Skalowalność geograficzna (aplikacja i interfejs wymagają zbyt dużej synchronizacji):
W tym przypadku najlepiej użyć technik buforowania (stan interfejsu utrzymywany jest po stronie aplikacji).

12. Jak zapobiec, aby aplikacja nie obchodziła zarządcy okien, wskutek czego mogłaby spowodować całkowity bałagan na ekranie?

Odpowiedź:
Można na przykład skorzystać z podejścia opartego na mikrojądrze,
w którym zarządca okien jest uruchamiany w taki sposób, 
że wszystkie operacje okna przechodzą przez jądro.
Jest to istota przeniesienia modelu klient-serwer na pojedynczy komputer.